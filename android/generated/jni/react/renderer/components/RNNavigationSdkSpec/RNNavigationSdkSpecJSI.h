/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeNavAutoModuleCameraPositionSpec

template <typename P0, typename P1, typename P2, typename P3>
struct NativeNavAutoModuleCameraPositionSpec {
  P0 target;
  P1 bearing;
  P2 tilt;
  P3 zoom;
  bool operator==(const NativeNavAutoModuleCameraPositionSpec &other) const {
    return target == other.target && bearing == other.bearing && tilt == other.tilt && zoom == other.zoom;
  }
};

template <typename T>
struct NativeNavAutoModuleCameraPositionSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.target)>(rt, value.getProperty(rt, "target"), jsInvoker),
      bridging::fromJs<decltype(types.bearing)>(rt, value.getProperty(rt, "bearing"), jsInvoker),
      bridging::fromJs<decltype(types.tilt)>(rt, value.getProperty(rt, "tilt"), jsInvoker),
      bridging::fromJs<decltype(types.zoom)>(rt, value.getProperty(rt, "zoom"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::Object> targetToJs(jsi::Runtime &rt, decltype(types.target) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> bearingToJs(jsi::Runtime &rt, decltype(types.bearing) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> tiltToJs(jsi::Runtime &rt, decltype(types.tilt) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zoomToJs(jsi::Runtime &rt, decltype(types.zoom) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.target) {
      result.setProperty(rt, "target", bridging::toJs(rt, value.target.value(), jsInvoker));
    }
    if (value.bearing) {
      result.setProperty(rt, "bearing", bridging::toJs(rt, value.bearing.value(), jsInvoker));
    }
    if (value.tilt) {
      result.setProperty(rt, "tilt", bridging::toJs(rt, value.tilt.value(), jsInvoker));
    }
    if (value.zoom) {
      result.setProperty(rt, "zoom", bridging::toJs(rt, value.zoom.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavAutoModuleCircleOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct NativeNavAutoModuleCircleOptionsSpec {
  P0 center;
  P1 id;
  P2 radius;
  P3 strokeWidth;
  P4 strokeColor;
  P5 fillColor;
  P6 clickable;
  P7 visible;
  P8 zIndex;
  bool operator==(const NativeNavAutoModuleCircleOptionsSpec &other) const {
    return center == other.center && id == other.id && radius == other.radius && strokeWidth == other.strokeWidth && strokeColor == other.strokeColor && fillColor == other.fillColor && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavAutoModuleCircleOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.center)>(rt, value.getProperty(rt, "center"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.radius)>(rt, value.getProperty(rt, "radius"), jsInvoker),
      bridging::fromJs<decltype(types.strokeWidth)>(rt, value.getProperty(rt, "strokeWidth"), jsInvoker),
      bridging::fromJs<decltype(types.strokeColor)>(rt, value.getProperty(rt, "strokeColor"), jsInvoker),
      bridging::fromJs<decltype(types.fillColor)>(rt, value.getProperty(rt, "fillColor"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object centerToJs(jsi::Runtime &rt, decltype(types.center) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static double radiusToJs(jsi::Runtime &rt, decltype(types.radius) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> strokeWidthToJs(jsi::Runtime &rt, decltype(types.strokeWidth) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> strokeColorToJs(jsi::Runtime &rt, decltype(types.strokeColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fillColorToJs(jsi::Runtime &rt, decltype(types.fillColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "center", bridging::toJs(rt, value.center, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    result.setProperty(rt, "radius", bridging::toJs(rt, value.radius, jsInvoker));
    if (value.strokeWidth) {
      result.setProperty(rt, "strokeWidth", bridging::toJs(rt, value.strokeWidth.value(), jsInvoker));
    }
    if (value.strokeColor) {
      result.setProperty(rt, "strokeColor", bridging::toJs(rt, value.strokeColor.value(), jsInvoker));
    }
    if (value.fillColor) {
      result.setProperty(rt, "fillColor", bridging::toJs(rt, value.fillColor.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavAutoModuleCustomNavigationAutoEventSpec

template <typename P0, typename P1>
struct NativeNavAutoModuleCustomNavigationAutoEventSpec {
  P0 type;
  P1 data;
  bool operator==(const NativeNavAutoModuleCustomNavigationAutoEventSpec &other) const {
    return type == other.type && data == other.data;
  }
};

template <typename T>
struct NativeNavAutoModuleCustomNavigationAutoEventSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.data)>(rt, value.getProperty(rt, "data"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> dataToJs(jsi::Runtime &rt, decltype(types.data) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    result.setProperty(rt, "data", bridging::toJs(rt, value.data, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavAutoModuleMarkerOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
struct NativeNavAutoModuleMarkerOptionsSpec {
  P0 position;
  P1 id;
  P2 imgPath;
  P3 title;
  P4 snippet;
  P5 alpha;
  P6 rotation;
  P7 draggable;
  P8 flat;
  P9 visible;
  P10 zIndex;
  bool operator==(const NativeNavAutoModuleMarkerOptionsSpec &other) const {
    return position == other.position && id == other.id && imgPath == other.imgPath && title == other.title && snippet == other.snippet && alpha == other.alpha && rotation == other.rotation && draggable == other.draggable && flat == other.flat && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavAutoModuleMarkerOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.position)>(rt, value.getProperty(rt, "position"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.imgPath)>(rt, value.getProperty(rt, "imgPath"), jsInvoker),
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.snippet)>(rt, value.getProperty(rt, "snippet"), jsInvoker),
      bridging::fromJs<decltype(types.alpha)>(rt, value.getProperty(rt, "alpha"), jsInvoker),
      bridging::fromJs<decltype(types.rotation)>(rt, value.getProperty(rt, "rotation"), jsInvoker),
      bridging::fromJs<decltype(types.draggable)>(rt, value.getProperty(rt, "draggable"), jsInvoker),
      bridging::fromJs<decltype(types.flat)>(rt, value.getProperty(rt, "flat"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object positionToJs(jsi::Runtime &rt, decltype(types.position) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> imgPathToJs(jsi::Runtime &rt, decltype(types.imgPath) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> snippetToJs(jsi::Runtime &rt, decltype(types.snippet) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> alphaToJs(jsi::Runtime &rt, decltype(types.alpha) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> rotationToJs(jsi::Runtime &rt, decltype(types.rotation) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> draggableToJs(jsi::Runtime &rt, decltype(types.draggable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> flatToJs(jsi::Runtime &rt, decltype(types.flat) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "position", bridging::toJs(rt, value.position, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    if (value.imgPath) {
      result.setProperty(rt, "imgPath", bridging::toJs(rt, value.imgPath.value(), jsInvoker));
    }
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.snippet) {
      result.setProperty(rt, "snippet", bridging::toJs(rt, value.snippet.value(), jsInvoker));
    }
    if (value.alpha) {
      result.setProperty(rt, "alpha", bridging::toJs(rt, value.alpha.value(), jsInvoker));
    }
    if (value.rotation) {
      result.setProperty(rt, "rotation", bridging::toJs(rt, value.rotation.value(), jsInvoker));
    }
    if (value.draggable) {
      result.setProperty(rt, "draggable", bridging::toJs(rt, value.draggable.value(), jsInvoker));
    }
    if (value.flat) {
      result.setProperty(rt, "flat", bridging::toJs(rt, value.flat.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavAutoModulePolygonOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct NativeNavAutoModulePolygonOptionsSpec {
  P0 points;
  P1 id;
  P2 holes;
  P3 strokeWidth;
  P4 strokeColor;
  P5 fillColor;
  P6 geodesic;
  P7 clickable;
  P8 visible;
  P9 zIndex;
  bool operator==(const NativeNavAutoModulePolygonOptionsSpec &other) const {
    return points == other.points && id == other.id && holes == other.holes && strokeWidth == other.strokeWidth && strokeColor == other.strokeColor && fillColor == other.fillColor && geodesic == other.geodesic && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavAutoModulePolygonOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.points)>(rt, value.getProperty(rt, "points"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.holes)>(rt, value.getProperty(rt, "holes"), jsInvoker),
      bridging::fromJs<decltype(types.strokeWidth)>(rt, value.getProperty(rt, "strokeWidth"), jsInvoker),
      bridging::fromJs<decltype(types.strokeColor)>(rt, value.getProperty(rt, "strokeColor"), jsInvoker),
      bridging::fromJs<decltype(types.fillColor)>(rt, value.getProperty(rt, "fillColor"), jsInvoker),
      bridging::fromJs<decltype(types.geodesic)>(rt, value.getProperty(rt, "geodesic"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array pointsToJs(jsi::Runtime &rt, decltype(types.points) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array holesToJs(jsi::Runtime &rt, decltype(types.holes) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> strokeWidthToJs(jsi::Runtime &rt, decltype(types.strokeWidth) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> strokeColorToJs(jsi::Runtime &rt, decltype(types.strokeColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fillColorToJs(jsi::Runtime &rt, decltype(types.fillColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> geodesicToJs(jsi::Runtime &rt, decltype(types.geodesic) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "points", bridging::toJs(rt, value.points, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    result.setProperty(rt, "holes", bridging::toJs(rt, value.holes, jsInvoker));
    if (value.strokeWidth) {
      result.setProperty(rt, "strokeWidth", bridging::toJs(rt, value.strokeWidth.value(), jsInvoker));
    }
    if (value.strokeColor) {
      result.setProperty(rt, "strokeColor", bridging::toJs(rt, value.strokeColor.value(), jsInvoker));
    }
    if (value.fillColor) {
      result.setProperty(rt, "fillColor", bridging::toJs(rt, value.fillColor.value(), jsInvoker));
    }
    if (value.geodesic) {
      result.setProperty(rt, "geodesic", bridging::toJs(rt, value.geodesic.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavAutoModulePolylineOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativeNavAutoModulePolylineOptionsSpec {
  P0 points;
  P1 id;
  P2 color;
  P3 width;
  P4 clickable;
  P5 visible;
  P6 zIndex;
  bool operator==(const NativeNavAutoModulePolylineOptionsSpec &other) const {
    return points == other.points && id == other.id && color == other.color && width == other.width && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavAutoModulePolylineOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.points)>(rt, value.getProperty(rt, "points"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.color)>(rt, value.getProperty(rt, "color"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array pointsToJs(jsi::Runtime &rt, decltype(types.points) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> colorToJs(jsi::Runtime &rt, decltype(types.color) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "points", bridging::toJs(rt, value.points, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    if (value.color) {
      result.setProperty(rt, "color", bridging::toJs(rt, value.color.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeNavAutoModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNavAutoModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value isAutoScreenAvailable(jsi::Runtime &rt) = 0;
  virtual void setMapType(jsi::Runtime &rt, double mapType) = 0;
  virtual void setMapStyle(jsi::Runtime &rt, jsi::String mapStyle) = 0;
  virtual jsi::Value clearMapView(jsi::Runtime &rt) = 0;
  virtual jsi::Value addCircle(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value addMarker(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value addPolyline(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value addPolygon(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value addGroundOverlay(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value moveCamera(jsi::Runtime &rt, jsi::Object cameraPosition) = 0;
  virtual jsi::Value removeMarker(jsi::Runtime &rt, jsi::String id) = 0;
  virtual jsi::Value removePolyline(jsi::Runtime &rt, jsi::String id) = 0;
  virtual jsi::Value removePolygon(jsi::Runtime &rt, jsi::String id) = 0;
  virtual jsi::Value removeCircle(jsi::Runtime &rt, jsi::String id) = 0;
  virtual jsi::Value removeGroundOverlay(jsi::Runtime &rt, jsi::String id) = 0;
  virtual void setIndoorEnabled(jsi::Runtime &rt, bool isOn) = 0;
  virtual void setTrafficEnabled(jsi::Runtime &rt, bool isOn) = 0;
  virtual void setCompassEnabled(jsi::Runtime &rt, bool isOn) = 0;
  virtual void setMyLocationEnabled(jsi::Runtime &rt, bool isOn) = 0;
  virtual void setBuildingsEnabled(jsi::Runtime &rt, bool isOn) = 0;
  virtual jsi::Value setZoomLevel(jsi::Runtime &rt, double zoomLevel) = 0;
  virtual void setMapPadding(jsi::Runtime &rt, double top, double left, double bottom, double right) = 0;
  virtual jsi::Value getCameraPosition(jsi::Runtime &rt) = 0;
  virtual jsi::Value getMyLocation(jsi::Runtime &rt) = 0;
  virtual jsi::Value getUiSettings(jsi::Runtime &rt) = 0;
  virtual jsi::Value isMyLocationEnabled(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNavAutoModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NavAutoModule";

protected:
  NativeNavAutoModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNavAutoModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  template <typename OnAutoScreenAvailabilityChangedType> void emitOnAutoScreenAvailabilityChanged(OnAutoScreenAvailabilityChangedType value) {
    static_assert(bridging::supportsFromJs<OnAutoScreenAvailabilityChangedType, bool>, "value cannnot be converted to bool");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onAutoScreenAvailabilityChanged"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnCustomNavigationAutoEventType> void emitOnCustomNavigationAutoEvent(OnCustomNavigationAutoEventType value) {
    static_assert(bridging::supportsFromJs<OnCustomNavigationAutoEventType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onCustomNavigationAutoEvent"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeNavAutoModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNavAutoModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onAutoScreenAvailabilityChanged"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onCustomNavigationAutoEvent"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    jsi::Value isAutoScreenAvailable(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isAutoScreenAvailable) == 1,
          "Expected isAutoScreenAvailable(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isAutoScreenAvailable, jsInvoker_, instance_);
    }
    void setMapType(jsi::Runtime &rt, double mapType) override {
      static_assert(
          bridging::getParameterCount(&T::setMapType) == 2,
          "Expected setMapType(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMapType, jsInvoker_, instance_, std::move(mapType));
    }
    void setMapStyle(jsi::Runtime &rt, jsi::String mapStyle) override {
      static_assert(
          bridging::getParameterCount(&T::setMapStyle) == 2,
          "Expected setMapStyle(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMapStyle, jsInvoker_, instance_, std::move(mapStyle));
    }
    jsi::Value clearMapView(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearMapView) == 1,
          "Expected clearMapView(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearMapView, jsInvoker_, instance_);
    }
    jsi::Value addCircle(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addCircle) == 2,
          "Expected addCircle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addCircle, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value addMarker(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addMarker) == 2,
          "Expected addMarker(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addMarker, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value addPolyline(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addPolyline) == 2,
          "Expected addPolyline(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addPolyline, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value addPolygon(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addPolygon) == 2,
          "Expected addPolygon(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addPolygon, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value addGroundOverlay(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addGroundOverlay) == 2,
          "Expected addGroundOverlay(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addGroundOverlay, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value moveCamera(jsi::Runtime &rt, jsi::Object cameraPosition) override {
      static_assert(
          bridging::getParameterCount(&T::moveCamera) == 2,
          "Expected moveCamera(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveCamera, jsInvoker_, instance_, std::move(cameraPosition));
    }
    jsi::Value removeMarker(jsi::Runtime &rt, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeMarker) == 2,
          "Expected removeMarker(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeMarker, jsInvoker_, instance_, std::move(id));
    }
    jsi::Value removePolyline(jsi::Runtime &rt, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removePolyline) == 2,
          "Expected removePolyline(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removePolyline, jsInvoker_, instance_, std::move(id));
    }
    jsi::Value removePolygon(jsi::Runtime &rt, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removePolygon) == 2,
          "Expected removePolygon(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removePolygon, jsInvoker_, instance_, std::move(id));
    }
    jsi::Value removeCircle(jsi::Runtime &rt, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeCircle) == 2,
          "Expected removeCircle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeCircle, jsInvoker_, instance_, std::move(id));
    }
    jsi::Value removeGroundOverlay(jsi::Runtime &rt, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeGroundOverlay) == 2,
          "Expected removeGroundOverlay(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeGroundOverlay, jsInvoker_, instance_, std::move(id));
    }
    void setIndoorEnabled(jsi::Runtime &rt, bool isOn) override {
      static_assert(
          bridging::getParameterCount(&T::setIndoorEnabled) == 2,
          "Expected setIndoorEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIndoorEnabled, jsInvoker_, instance_, std::move(isOn));
    }
    void setTrafficEnabled(jsi::Runtime &rt, bool isOn) override {
      static_assert(
          bridging::getParameterCount(&T::setTrafficEnabled) == 2,
          "Expected setTrafficEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTrafficEnabled, jsInvoker_, instance_, std::move(isOn));
    }
    void setCompassEnabled(jsi::Runtime &rt, bool isOn) override {
      static_assert(
          bridging::getParameterCount(&T::setCompassEnabled) == 2,
          "Expected setCompassEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setCompassEnabled, jsInvoker_, instance_, std::move(isOn));
    }
    void setMyLocationEnabled(jsi::Runtime &rt, bool isOn) override {
      static_assert(
          bridging::getParameterCount(&T::setMyLocationEnabled) == 2,
          "Expected setMyLocationEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMyLocationEnabled, jsInvoker_, instance_, std::move(isOn));
    }
    void setBuildingsEnabled(jsi::Runtime &rt, bool isOn) override {
      static_assert(
          bridging::getParameterCount(&T::setBuildingsEnabled) == 2,
          "Expected setBuildingsEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setBuildingsEnabled, jsInvoker_, instance_, std::move(isOn));
    }
    jsi::Value setZoomLevel(jsi::Runtime &rt, double zoomLevel) override {
      static_assert(
          bridging::getParameterCount(&T::setZoomLevel) == 2,
          "Expected setZoomLevel(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setZoomLevel, jsInvoker_, instance_, std::move(zoomLevel));
    }
    void setMapPadding(jsi::Runtime &rt, double top, double left, double bottom, double right) override {
      static_assert(
          bridging::getParameterCount(&T::setMapPadding) == 5,
          "Expected setMapPadding(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMapPadding, jsInvoker_, instance_, std::move(top), std::move(left), std::move(bottom), std::move(right));
    }
    jsi::Value getCameraPosition(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCameraPosition) == 1,
          "Expected getCameraPosition(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCameraPosition, jsInvoker_, instance_);
    }
    jsi::Value getMyLocation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getMyLocation) == 1,
          "Expected getMyLocation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getMyLocation, jsInvoker_, instance_);
    }
    jsi::Value getUiSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getUiSettings) == 1,
          "Expected getUiSettings(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getUiSettings, jsInvoker_, instance_);
    }
    jsi::Value isMyLocationEnabled(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isMyLocationEnabled) == 1,
          "Expected isMyLocationEnabled(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isMyLocationEnabled, jsInvoker_, instance_);
    }

  private:
    friend class NativeNavAutoModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


#pragma mark - NativeNavModuleNavigationInitializationStatusSpec

enum class NativeNavModuleNavigationInitializationStatusSpec { UNKNOWN, NOT_AUTHORIZED, TERMS_NOT_ACCEPTED, NETWORK_ERROR, LOCATION_PERMISSION_MISSING };

template <>
struct Bridging<NativeNavModuleNavigationInitializationStatusSpec> {
  static NativeNavModuleNavigationInitializationStatusSpec fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "UNKNOWN") {
      return NativeNavModuleNavigationInitializationStatusSpec::UNKNOWN;
    } else if (value == "NOT_AUTHORIZED") {
      return NativeNavModuleNavigationInitializationStatusSpec::NOT_AUTHORIZED;
    } else if (value == "TERMS_NOT_ACCEPTED") {
      return NativeNavModuleNavigationInitializationStatusSpec::TERMS_NOT_ACCEPTED;
    } else if (value == "NETWORK_ERROR") {
      return NativeNavModuleNavigationInitializationStatusSpec::NETWORK_ERROR;
    } else if (value == "LOCATION_PERMISSION_MISSING") {
      return NativeNavModuleNavigationInitializationStatusSpec::LOCATION_PERMISSION_MISSING;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeNavModuleNavigationInitializationStatusSpec value) {
    if (value == NativeNavModuleNavigationInitializationStatusSpec::UNKNOWN) {
      return bridging::toJs(rt, "UNKNOWN");
    } else if (value == NativeNavModuleNavigationInitializationStatusSpec::NOT_AUTHORIZED) {
      return bridging::toJs(rt, "NOT_AUTHORIZED");
    } else if (value == NativeNavModuleNavigationInitializationStatusSpec::TERMS_NOT_ACCEPTED) {
      return bridging::toJs(rt, "TERMS_NOT_ACCEPTED");
    } else if (value == NativeNavModuleNavigationInitializationStatusSpec::NETWORK_ERROR) {
      return bridging::toJs(rt, "NETWORK_ERROR");
    } else if (value == NativeNavModuleNavigationInitializationStatusSpec::LOCATION_PERMISSION_MISSING) {
      return bridging::toJs(rt, "LOCATION_PERMISSION_MISSING");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value");
    }
  }
};

#pragma mark - NativeNavModuleRouteStatusSpec

enum class NativeNavModuleRouteStatusSpec { OK, NO_ROUTE_FOUND, NETWORK_ERROR, QUOTA_CHECK_FAILED, ROUTE_CANCELED, LOCATION_DISABLED, LOCATION_UNKNOWN, WAYPOINT_ERROR, INVALID_PLACE_ID, UNKNOWN };

template <>
struct Bridging<NativeNavModuleRouteStatusSpec> {
  static NativeNavModuleRouteStatusSpec fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "OK") {
      return NativeNavModuleRouteStatusSpec::OK;
    } else if (value == "NO_ROUTE_FOUND") {
      return NativeNavModuleRouteStatusSpec::NO_ROUTE_FOUND;
    } else if (value == "NETWORK_ERROR") {
      return NativeNavModuleRouteStatusSpec::NETWORK_ERROR;
    } else if (value == "QUOTA_CHECK_FAILED") {
      return NativeNavModuleRouteStatusSpec::QUOTA_CHECK_FAILED;
    } else if (value == "ROUTE_CANCELED") {
      return NativeNavModuleRouteStatusSpec::ROUTE_CANCELED;
    } else if (value == "LOCATION_DISABLED") {
      return NativeNavModuleRouteStatusSpec::LOCATION_DISABLED;
    } else if (value == "LOCATION_UNKNOWN") {
      return NativeNavModuleRouteStatusSpec::LOCATION_UNKNOWN;
    } else if (value == "WAYPOINT_ERROR") {
      return NativeNavModuleRouteStatusSpec::WAYPOINT_ERROR;
    } else if (value == "INVALID_PLACE_ID") {
      return NativeNavModuleRouteStatusSpec::INVALID_PLACE_ID;
    } else if (value == "UNKNOWN") {
      return NativeNavModuleRouteStatusSpec::UNKNOWN;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeNavModuleRouteStatusSpec value) {
    if (value == NativeNavModuleRouteStatusSpec::OK) {
      return bridging::toJs(rt, "OK");
    } else if (value == NativeNavModuleRouteStatusSpec::NO_ROUTE_FOUND) {
      return bridging::toJs(rt, "NO_ROUTE_FOUND");
    } else if (value == NativeNavModuleRouteStatusSpec::NETWORK_ERROR) {
      return bridging::toJs(rt, "NETWORK_ERROR");
    } else if (value == NativeNavModuleRouteStatusSpec::QUOTA_CHECK_FAILED) {
      return bridging::toJs(rt, "QUOTA_CHECK_FAILED");
    } else if (value == NativeNavModuleRouteStatusSpec::ROUTE_CANCELED) {
      return bridging::toJs(rt, "ROUTE_CANCELED");
    } else if (value == NativeNavModuleRouteStatusSpec::LOCATION_DISABLED) {
      return bridging::toJs(rt, "LOCATION_DISABLED");
    } else if (value == NativeNavModuleRouteStatusSpec::LOCATION_UNKNOWN) {
      return bridging::toJs(rt, "LOCATION_UNKNOWN");
    } else if (value == NativeNavModuleRouteStatusSpec::WAYPOINT_ERROR) {
      return bridging::toJs(rt, "WAYPOINT_ERROR");
    } else if (value == NativeNavModuleRouteStatusSpec::INVALID_PLACE_ID) {
      return bridging::toJs(rt, "INVALID_PLACE_ID");
    } else if (value == NativeNavModuleRouteStatusSpec::UNKNOWN) {
      return bridging::toJs(rt, "UNKNOWN");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value");
    }
  }
};
  
#pragma mark - NativeNavModuleArrivalEventSpec

template <typename P0, typename P1>
struct NativeNavModuleArrivalEventSpec {
  P0 waypoint;
  P1 isFinalDestination;
  bool operator==(const NativeNavModuleArrivalEventSpec &other) const {
    return waypoint == other.waypoint && isFinalDestination == other.isFinalDestination;
  }
};

template <typename T>
struct NativeNavModuleArrivalEventSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.waypoint)>(rt, value.getProperty(rt, "waypoint"), jsInvoker),
      bridging::fromJs<decltype(types.isFinalDestination)>(rt, value.getProperty(rt, "isFinalDestination"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object waypointToJs(jsi::Runtime &rt, decltype(types.waypoint) value) {
    return bridging::toJs(rt, value);
  }

  static bool isFinalDestinationToJs(jsi::Runtime &rt, decltype(types.isFinalDestination) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "waypoint", bridging::toJs(rt, value.waypoint, jsInvoker));
    if (value.isFinalDestination) {
      result.setProperty(rt, "isFinalDestination", bridging::toJs(rt, value.isFinalDestination.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavModuleDisplayOptionsSpec

template <typename P0, typename P1, typename P2>
struct NativeNavModuleDisplayOptionsSpec {
  P0 showDestinationMarkers;
  P1 showStopSigns;
  P2 showTrafficLights;
  bool operator==(const NativeNavModuleDisplayOptionsSpec &other) const {
    return showDestinationMarkers == other.showDestinationMarkers && showStopSigns == other.showStopSigns && showTrafficLights == other.showTrafficLights;
  }
};

template <typename T>
struct NativeNavModuleDisplayOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.showDestinationMarkers)>(rt, value.getProperty(rt, "showDestinationMarkers"), jsInvoker),
      bridging::fromJs<decltype(types.showStopSigns)>(rt, value.getProperty(rt, "showStopSigns"), jsInvoker),
      bridging::fromJs<decltype(types.showTrafficLights)>(rt, value.getProperty(rt, "showTrafficLights"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool showDestinationMarkersToJs(jsi::Runtime &rt, decltype(types.showDestinationMarkers) value) {
    return bridging::toJs(rt, value);
  }

  static bool showStopSignsToJs(jsi::Runtime &rt, decltype(types.showStopSigns) value) {
    return bridging::toJs(rt, value);
  }

  static bool showTrafficLightsToJs(jsi::Runtime &rt, decltype(types.showTrafficLights) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.showDestinationMarkers) {
      result.setProperty(rt, "showDestinationMarkers", bridging::toJs(rt, value.showDestinationMarkers.value(), jsInvoker));
    }
    if (value.showStopSigns) {
      result.setProperty(rt, "showStopSigns", bridging::toJs(rt, value.showStopSigns.value(), jsInvoker));
    }
    if (value.showTrafficLights) {
      result.setProperty(rt, "showTrafficLights", bridging::toJs(rt, value.showTrafficLights.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavModuleLatLngSpec

template <typename P0, typename P1>
struct NativeNavModuleLatLngSpec {
  P0 lat;
  P1 lng;
  bool operator==(const NativeNavModuleLatLngSpec &other) const {
    return lat == other.lat && lng == other.lng;
  }
};

template <typename T>
struct NativeNavModuleLatLngSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.lat)>(rt, value.getProperty(rt, "lat"), jsInvoker),
      bridging::fromJs<decltype(types.lng)>(rt, value.getProperty(rt, "lng"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double latToJs(jsi::Runtime &rt, decltype(types.lat) value) {
    return bridging::toJs(rt, value);
  }

  static double lngToJs(jsi::Runtime &rt, decltype(types.lng) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "lat", bridging::toJs(rt, value.lat, jsInvoker));
    result.setProperty(rt, "lng", bridging::toJs(rt, value.lng, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleLocationSimulationOptionsSpec

template <typename P0>
struct NativeNavModuleLocationSimulationOptionsSpec {
  P0 speedMultiplier;
  bool operator==(const NativeNavModuleLocationSimulationOptionsSpec &other) const {
    return speedMultiplier == other.speedMultiplier;
  }
};

template <typename T>
struct NativeNavModuleLocationSimulationOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.speedMultiplier)>(rt, value.getProperty(rt, "speedMultiplier"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double speedMultiplierToJs(jsi::Runtime &rt, decltype(types.speedMultiplier) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "speedMultiplier", bridging::toJs(rt, value.speedMultiplier, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleLocationSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct NativeNavModuleLocationSpec {
  P0 lat;
  P1 lng;
  P2 altitude;
  P3 bearing;
  P4 speed;
  P5 accuracy;
  P6 verticalAccuracy;
  P7 provider;
  P8 time;
  bool operator==(const NativeNavModuleLocationSpec &other) const {
    return lat == other.lat && lng == other.lng && altitude == other.altitude && bearing == other.bearing && speed == other.speed && accuracy == other.accuracy && verticalAccuracy == other.verticalAccuracy && provider == other.provider && time == other.time;
  }
};

template <typename T>
struct NativeNavModuleLocationSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.lat)>(rt, value.getProperty(rt, "lat"), jsInvoker),
      bridging::fromJs<decltype(types.lng)>(rt, value.getProperty(rt, "lng"), jsInvoker),
      bridging::fromJs<decltype(types.altitude)>(rt, value.getProperty(rt, "altitude"), jsInvoker),
      bridging::fromJs<decltype(types.bearing)>(rt, value.getProperty(rt, "bearing"), jsInvoker),
      bridging::fromJs<decltype(types.speed)>(rt, value.getProperty(rt, "speed"), jsInvoker),
      bridging::fromJs<decltype(types.accuracy)>(rt, value.getProperty(rt, "accuracy"), jsInvoker),
      bridging::fromJs<decltype(types.verticalAccuracy)>(rt, value.getProperty(rt, "verticalAccuracy"), jsInvoker),
      bridging::fromJs<decltype(types.provider)>(rt, value.getProperty(rt, "provider"), jsInvoker),
      bridging::fromJs<decltype(types.time)>(rt, value.getProperty(rt, "time"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double latToJs(jsi::Runtime &rt, decltype(types.lat) value) {
    return bridging::toJs(rt, value);
  }

  static double lngToJs(jsi::Runtime &rt, decltype(types.lng) value) {
    return bridging::toJs(rt, value);
  }

  static double altitudeToJs(jsi::Runtime &rt, decltype(types.altitude) value) {
    return bridging::toJs(rt, value);
  }

  static double bearingToJs(jsi::Runtime &rt, decltype(types.bearing) value) {
    return bridging::toJs(rt, value);
  }

  static double speedToJs(jsi::Runtime &rt, decltype(types.speed) value) {
    return bridging::toJs(rt, value);
  }

  static double accuracyToJs(jsi::Runtime &rt, decltype(types.accuracy) value) {
    return bridging::toJs(rt, value);
  }

  static double verticalAccuracyToJs(jsi::Runtime &rt, decltype(types.verticalAccuracy) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerToJs(jsi::Runtime &rt, decltype(types.provider) value) {
    return bridging::toJs(rt, value);
  }

  static double timeToJs(jsi::Runtime &rt, decltype(types.time) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "lat", bridging::toJs(rt, value.lat, jsInvoker));
    result.setProperty(rt, "lng", bridging::toJs(rt, value.lng, jsInvoker));
    if (value.altitude) {
      result.setProperty(rt, "altitude", bridging::toJs(rt, value.altitude.value(), jsInvoker));
    }
    if (value.bearing) {
      result.setProperty(rt, "bearing", bridging::toJs(rt, value.bearing.value(), jsInvoker));
    }
    result.setProperty(rt, "speed", bridging::toJs(rt, value.speed, jsInvoker));
    if (value.accuracy) {
      result.setProperty(rt, "accuracy", bridging::toJs(rt, value.accuracy.value(), jsInvoker));
    }
    if (value.verticalAccuracy) {
      result.setProperty(rt, "verticalAccuracy", bridging::toJs(rt, value.verticalAccuracy.value(), jsInvoker));
    }
    if (value.provider) {
      result.setProperty(rt, "provider", bridging::toJs(rt, value.provider.value(), jsInvoker));
    }
    result.setProperty(rt, "time", bridging::toJs(rt, value.time, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleRoutingOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeNavModuleRoutingOptionsSpec {
  P0 travelMode;
  P1 routingStrategy;
  P2 alternateRoutesStrategy;
  P3 avoidFerries;
  P4 avoidTolls;
  P5 avoidHighways;
  bool operator==(const NativeNavModuleRoutingOptionsSpec &other) const {
    return travelMode == other.travelMode && routingStrategy == other.routingStrategy && alternateRoutesStrategy == other.alternateRoutesStrategy && avoidFerries == other.avoidFerries && avoidTolls == other.avoidTolls && avoidHighways == other.avoidHighways;
  }
};

template <typename T>
struct NativeNavModuleRoutingOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.travelMode)>(rt, value.getProperty(rt, "travelMode"), jsInvoker),
      bridging::fromJs<decltype(types.routingStrategy)>(rt, value.getProperty(rt, "routingStrategy"), jsInvoker),
      bridging::fromJs<decltype(types.alternateRoutesStrategy)>(rt, value.getProperty(rt, "alternateRoutesStrategy"), jsInvoker),
      bridging::fromJs<decltype(types.avoidFerries)>(rt, value.getProperty(rt, "avoidFerries"), jsInvoker),
      bridging::fromJs<decltype(types.avoidTolls)>(rt, value.getProperty(rt, "avoidTolls"), jsInvoker),
      bridging::fromJs<decltype(types.avoidHighways)>(rt, value.getProperty(rt, "avoidHighways"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double travelModeToJs(jsi::Runtime &rt, decltype(types.travelMode) value) {
    return bridging::toJs(rt, value);
  }

  static double routingStrategyToJs(jsi::Runtime &rt, decltype(types.routingStrategy) value) {
    return bridging::toJs(rt, value);
  }

  static double alternateRoutesStrategyToJs(jsi::Runtime &rt, decltype(types.alternateRoutesStrategy) value) {
    return bridging::toJs(rt, value);
  }

  static bool avoidFerriesToJs(jsi::Runtime &rt, decltype(types.avoidFerries) value) {
    return bridging::toJs(rt, value);
  }

  static bool avoidTollsToJs(jsi::Runtime &rt, decltype(types.avoidTolls) value) {
    return bridging::toJs(rt, value);
  }

  static bool avoidHighwaysToJs(jsi::Runtime &rt, decltype(types.avoidHighways) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.travelMode) {
      result.setProperty(rt, "travelMode", bridging::toJs(rt, value.travelMode.value(), jsInvoker));
    }
    if (value.routingStrategy) {
      result.setProperty(rt, "routingStrategy", bridging::toJs(rt, value.routingStrategy.value(), jsInvoker));
    }
    if (value.alternateRoutesStrategy) {
      result.setProperty(rt, "alternateRoutesStrategy", bridging::toJs(rt, value.alternateRoutesStrategy.value(), jsInvoker));
    }
    if (value.avoidFerries) {
      result.setProperty(rt, "avoidFerries", bridging::toJs(rt, value.avoidFerries.value(), jsInvoker));
    }
    if (value.avoidTolls) {
      result.setProperty(rt, "avoidTolls", bridging::toJs(rt, value.avoidTolls.value(), jsInvoker));
    }
    if (value.avoidHighways) {
      result.setProperty(rt, "avoidHighways", bridging::toJs(rt, value.avoidHighways.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavModuleSpeedAlertOptionsSpec

template <typename P0, typename P1, typename P2>
struct NativeNavModuleSpeedAlertOptionsSpec {
  P0 majorSpeedAlertPercentThreshold;
  P1 minorSpeedAlertPercentThreshold;
  P2 severityUpgradeDurationSeconds;
  bool operator==(const NativeNavModuleSpeedAlertOptionsSpec &other) const {
    return majorSpeedAlertPercentThreshold == other.majorSpeedAlertPercentThreshold && minorSpeedAlertPercentThreshold == other.minorSpeedAlertPercentThreshold && severityUpgradeDurationSeconds == other.severityUpgradeDurationSeconds;
  }
};

template <typename T>
struct NativeNavModuleSpeedAlertOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.majorSpeedAlertPercentThreshold)>(rt, value.getProperty(rt, "majorSpeedAlertPercentThreshold"), jsInvoker),
      bridging::fromJs<decltype(types.minorSpeedAlertPercentThreshold)>(rt, value.getProperty(rt, "minorSpeedAlertPercentThreshold"), jsInvoker),
      bridging::fromJs<decltype(types.severityUpgradeDurationSeconds)>(rt, value.getProperty(rt, "severityUpgradeDurationSeconds"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double majorSpeedAlertPercentThresholdToJs(jsi::Runtime &rt, decltype(types.majorSpeedAlertPercentThreshold) value) {
    return bridging::toJs(rt, value);
  }

  static double minorSpeedAlertPercentThresholdToJs(jsi::Runtime &rt, decltype(types.minorSpeedAlertPercentThreshold) value) {
    return bridging::toJs(rt, value);
  }

  static double severityUpgradeDurationSecondsToJs(jsi::Runtime &rt, decltype(types.severityUpgradeDurationSeconds) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "majorSpeedAlertPercentThreshold", bridging::toJs(rt, value.majorSpeedAlertPercentThreshold, jsInvoker));
    result.setProperty(rt, "minorSpeedAlertPercentThreshold", bridging::toJs(rt, value.minorSpeedAlertPercentThreshold, jsInvoker));
    result.setProperty(rt, "severityUpgradeDurationSeconds", bridging::toJs(rt, value.severityUpgradeDurationSeconds, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleStepInfoSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeNavModuleStepInfoSpec {
  P0 instruction;
  P1 distanceMeters;
  P2 durationSeconds;
  P3 maneuver;
  P4 position;
  bool operator==(const NativeNavModuleStepInfoSpec &other) const {
    return instruction == other.instruction && distanceMeters == other.distanceMeters && durationSeconds == other.durationSeconds && maneuver == other.maneuver && position == other.position;
  }
};

template <typename T>
struct NativeNavModuleStepInfoSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.instruction)>(rt, value.getProperty(rt, "instruction"), jsInvoker),
      bridging::fromJs<decltype(types.distanceMeters)>(rt, value.getProperty(rt, "distanceMeters"), jsInvoker),
      bridging::fromJs<decltype(types.durationSeconds)>(rt, value.getProperty(rt, "durationSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.maneuver)>(rt, value.getProperty(rt, "maneuver"), jsInvoker),
      bridging::fromJs<decltype(types.position)>(rt, value.getProperty(rt, "position"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String instructionToJs(jsi::Runtime &rt, decltype(types.instruction) value) {
    return bridging::toJs(rt, value);
  }

  static double distanceMetersToJs(jsi::Runtime &rt, decltype(types.distanceMeters) value) {
    return bridging::toJs(rt, value);
  }

  static double durationSecondsToJs(jsi::Runtime &rt, decltype(types.durationSeconds) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String maneuverToJs(jsi::Runtime &rt, decltype(types.maneuver) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object positionToJs(jsi::Runtime &rt, decltype(types.position) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "instruction", bridging::toJs(rt, value.instruction, jsInvoker));
    result.setProperty(rt, "distanceMeters", bridging::toJs(rt, value.distanceMeters, jsInvoker));
    result.setProperty(rt, "durationSeconds", bridging::toJs(rt, value.durationSeconds, jsInvoker));
    result.setProperty(rt, "maneuver", bridging::toJs(rt, value.maneuver, jsInvoker));
    result.setProperty(rt, "position", bridging::toJs(rt, value.position, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleTOSDialogOptionsSpec

template <typename P0, typename P1, typename P2>
struct NativeNavModuleTOSDialogOptionsSpec {
  P0 title;
  P1 companyName;
  P2 showOnlyDisclaimer;
  bool operator==(const NativeNavModuleTOSDialogOptionsSpec &other) const {
    return title == other.title && companyName == other.companyName && showOnlyDisclaimer == other.showOnlyDisclaimer;
  }
};

template <typename T>
struct NativeNavModuleTOSDialogOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.companyName)>(rt, value.getProperty(rt, "companyName"), jsInvoker),
      bridging::fromJs<decltype(types.showOnlyDisclaimer)>(rt, value.getProperty(rt, "showOnlyDisclaimer"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String companyNameToJs(jsi::Runtime &rt, decltype(types.companyName) value) {
    return bridging::toJs(rt, value);
  }

  static bool showOnlyDisclaimerToJs(jsi::Runtime &rt, decltype(types.showOnlyDisclaimer) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.companyName) {
      result.setProperty(rt, "companyName", bridging::toJs(rt, value.companyName.value(), jsInvoker));
    }
    if (value.showOnlyDisclaimer) {
      result.setProperty(rt, "showOnlyDisclaimer", bridging::toJs(rt, value.showOnlyDisclaimer.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavModuleTurnByTurnEventSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct NativeNavModuleTurnByTurnEventSpec {
  P0 navState;
  P1 routeChanged;
  P2 distanceToCurrentStepMeters;
  P3 distanceToFinalDestinationMeters;
  P4 timeToCurrentStepSeconds;
  P5 distanceToNextDestinationMeters;
  P6 timeToNextDestinationSeconds;
  P7 timeToFinalDestinationSeconds;
  P8 currentStep;
  P9 getRemainingSteps;
  bool operator==(const NativeNavModuleTurnByTurnEventSpec &other) const {
    return navState == other.navState && routeChanged == other.routeChanged && distanceToCurrentStepMeters == other.distanceToCurrentStepMeters && distanceToFinalDestinationMeters == other.distanceToFinalDestinationMeters && timeToCurrentStepSeconds == other.timeToCurrentStepSeconds && distanceToNextDestinationMeters == other.distanceToNextDestinationMeters && timeToNextDestinationSeconds == other.timeToNextDestinationSeconds && timeToFinalDestinationSeconds == other.timeToFinalDestinationSeconds && currentStep == other.currentStep && getRemainingSteps == other.getRemainingSteps;
  }
};

template <typename T>
struct NativeNavModuleTurnByTurnEventSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.navState)>(rt, value.getProperty(rt, "navState"), jsInvoker),
      bridging::fromJs<decltype(types.routeChanged)>(rt, value.getProperty(rt, "routeChanged"), jsInvoker),
      bridging::fromJs<decltype(types.distanceToCurrentStepMeters)>(rt, value.getProperty(rt, "distanceToCurrentStepMeters"), jsInvoker),
      bridging::fromJs<decltype(types.distanceToFinalDestinationMeters)>(rt, value.getProperty(rt, "distanceToFinalDestinationMeters"), jsInvoker),
      bridging::fromJs<decltype(types.timeToCurrentStepSeconds)>(rt, value.getProperty(rt, "timeToCurrentStepSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.distanceToNextDestinationMeters)>(rt, value.getProperty(rt, "distanceToNextDestinationMeters"), jsInvoker),
      bridging::fromJs<decltype(types.timeToNextDestinationSeconds)>(rt, value.getProperty(rt, "timeToNextDestinationSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.timeToFinalDestinationSeconds)>(rt, value.getProperty(rt, "timeToFinalDestinationSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.currentStep)>(rt, value.getProperty(rt, "currentStep"), jsInvoker),
      bridging::fromJs<decltype(types.getRemainingSteps)>(rt, value.getProperty(rt, "getRemainingSteps"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double navStateToJs(jsi::Runtime &rt, decltype(types.navState) value) {
    return bridging::toJs(rt, value);
  }

  static bool routeChangedToJs(jsi::Runtime &rt, decltype(types.routeChanged) value) {
    return bridging::toJs(rt, value);
  }

  static double distanceToCurrentStepMetersToJs(jsi::Runtime &rt, decltype(types.distanceToCurrentStepMeters) value) {
    return bridging::toJs(rt, value);
  }

  static double distanceToFinalDestinationMetersToJs(jsi::Runtime &rt, decltype(types.distanceToFinalDestinationMeters) value) {
    return bridging::toJs(rt, value);
  }

  static double timeToCurrentStepSecondsToJs(jsi::Runtime &rt, decltype(types.timeToCurrentStepSeconds) value) {
    return bridging::toJs(rt, value);
  }

  static double distanceToNextDestinationMetersToJs(jsi::Runtime &rt, decltype(types.distanceToNextDestinationMeters) value) {
    return bridging::toJs(rt, value);
  }

  static double timeToNextDestinationSecondsToJs(jsi::Runtime &rt, decltype(types.timeToNextDestinationSeconds) value) {
    return bridging::toJs(rt, value);
  }

  static double timeToFinalDestinationSecondsToJs(jsi::Runtime &rt, decltype(types.timeToFinalDestinationSeconds) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object currentStepToJs(jsi::Runtime &rt, decltype(types.currentStep) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array getRemainingStepsToJs(jsi::Runtime &rt, decltype(types.getRemainingSteps) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "navState", bridging::toJs(rt, value.navState, jsInvoker));
    result.setProperty(rt, "routeChanged", bridging::toJs(rt, value.routeChanged, jsInvoker));
    if (value.distanceToCurrentStepMeters) {
      result.setProperty(rt, "distanceToCurrentStepMeters", bridging::toJs(rt, value.distanceToCurrentStepMeters.value(), jsInvoker));
    }
    if (value.distanceToFinalDestinationMeters) {
      result.setProperty(rt, "distanceToFinalDestinationMeters", bridging::toJs(rt, value.distanceToFinalDestinationMeters.value(), jsInvoker));
    }
    if (value.timeToCurrentStepSeconds) {
      result.setProperty(rt, "timeToCurrentStepSeconds", bridging::toJs(rt, value.timeToCurrentStepSeconds.value(), jsInvoker));
    }
    if (value.distanceToNextDestinationMeters) {
      result.setProperty(rt, "distanceToNextDestinationMeters", bridging::toJs(rt, value.distanceToNextDestinationMeters.value(), jsInvoker));
    }
    if (value.timeToNextDestinationSeconds) {
      result.setProperty(rt, "timeToNextDestinationSeconds", bridging::toJs(rt, value.timeToNextDestinationSeconds.value(), jsInvoker));
    }
    if (value.timeToFinalDestinationSeconds) {
      result.setProperty(rt, "timeToFinalDestinationSeconds", bridging::toJs(rt, value.timeToFinalDestinationSeconds.value(), jsInvoker));
    }
    if (value.currentStep) {
      result.setProperty(rt, "currentStep", bridging::toJs(rt, value.currentStep.value(), jsInvoker));
    }
    result.setProperty(rt, "getRemainingSteps", bridging::toJs(rt, value.getRemainingSteps, jsInvoker));
    return result;
  }
};



#pragma mark - NativeNavModuleWaypointSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeNavModuleWaypointSpec {
  P0 placeId;
  P1 title;
  P2 vehicleStopover;
  P3 preferSameSideOfRoad;
  P4 position;
  P5 preferredHeading;
  bool operator==(const NativeNavModuleWaypointSpec &other) const {
    return placeId == other.placeId && title == other.title && vehicleStopover == other.vehicleStopover && preferSameSideOfRoad == other.preferSameSideOfRoad && position == other.position && preferredHeading == other.preferredHeading;
  }
};

template <typename T>
struct NativeNavModuleWaypointSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.placeId)>(rt, value.getProperty(rt, "placeId"), jsInvoker),
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.vehicleStopover)>(rt, value.getProperty(rt, "vehicleStopover"), jsInvoker),
      bridging::fromJs<decltype(types.preferSameSideOfRoad)>(rt, value.getProperty(rt, "preferSameSideOfRoad"), jsInvoker),
      bridging::fromJs<decltype(types.position)>(rt, value.getProperty(rt, "position"), jsInvoker),
      bridging::fromJs<decltype(types.preferredHeading)>(rt, value.getProperty(rt, "preferredHeading"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String placeIdToJs(jsi::Runtime &rt, decltype(types.placeId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static bool vehicleStopoverToJs(jsi::Runtime &rt, decltype(types.vehicleStopover) value) {
    return bridging::toJs(rt, value);
  }

  static bool preferSameSideOfRoadToJs(jsi::Runtime &rt, decltype(types.preferSameSideOfRoad) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object positionToJs(jsi::Runtime &rt, decltype(types.position) value) {
    return bridging::toJs(rt, value);
  }

  static double preferredHeadingToJs(jsi::Runtime &rt, decltype(types.preferredHeading) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.placeId) {
      result.setProperty(rt, "placeId", bridging::toJs(rt, value.placeId.value(), jsInvoker));
    }
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.vehicleStopover) {
      result.setProperty(rt, "vehicleStopover", bridging::toJs(rt, value.vehicleStopover.value(), jsInvoker));
    }
    if (value.preferSameSideOfRoad) {
      result.setProperty(rt, "preferSameSideOfRoad", bridging::toJs(rt, value.preferSameSideOfRoad.value(), jsInvoker));
    }
    if (value.position) {
      result.setProperty(rt, "position", bridging::toJs(rt, value.position.value(), jsInvoker));
    }
    if (value.preferredHeading) {
      result.setProperty(rt, "preferredHeading", bridging::toJs(rt, value.preferredHeading.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeNavModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNavModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value initializeNavigator(jsi::Runtime &rt, jsi::Object termsAndConditionsDialogOptions, double taskRemovedBehavior) = 0;
  virtual jsi::Value cleanup(jsi::Runtime &rt) = 0;
  virtual jsi::Value setDestinations(jsi::Runtime &rt, jsi::Array waypoints, std::optional<jsi::Object> routingOptions, std::optional<jsi::Object> displayOptions) = 0;
  virtual jsi::Value continueToNextDestination(jsi::Runtime &rt) = 0;
  virtual jsi::Value clearDestinations(jsi::Runtime &rt) = 0;
  virtual jsi::Value startGuidance(jsi::Runtime &rt) = 0;
  virtual jsi::Value stopGuidance(jsi::Runtime &rt) = 0;
  virtual jsi::Value setSpeedAlertOptions(jsi::Runtime &rt, std::optional<jsi::Object> alertOptions) = 0;
  virtual void setAbnormalTerminatingReportingEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual jsi::Value setAudioGuidanceType(jsi::Runtime &rt, double index) = 0;
  virtual void setBackgroundLocationUpdatesEnabled(jsi::Runtime &rt, bool isEnabled) = 0;
  virtual void setTurnByTurnLoggingEnabled(jsi::Runtime &rt, bool isEnabled) = 0;
  virtual jsi::Value areTermsAccepted(jsi::Runtime &rt) = 0;
  virtual jsi::Value getCurrentRouteSegment(jsi::Runtime &rt) = 0;
  virtual jsi::Value getRouteSegments(jsi::Runtime &rt) = 0;
  virtual jsi::Value getCurrentTimeAndDistance(jsi::Runtime &rt) = 0;
  virtual jsi::Value getTraveledPath(jsi::Runtime &rt) = 0;
  virtual jsi::Value getNavSDKVersion(jsi::Runtime &rt) = 0;
  virtual jsi::Value stopUpdatingLocation(jsi::Runtime &rt) = 0;
  virtual jsi::Value startUpdatingLocation(jsi::Runtime &rt) = 0;
  virtual jsi::Value simulateLocation(jsi::Runtime &rt, jsi::Object location) = 0;
  virtual jsi::Value resumeLocationSimulation(jsi::Runtime &rt) = 0;
  virtual jsi::Value pauseLocationSimulation(jsi::Runtime &rt) = 0;
  virtual jsi::Value simulateLocationsAlongExistingRoute(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value stopLocationSimulation(jsi::Runtime &rt) = 0;
  virtual void resetTermsAccepted(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeNavModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NavModule";

protected:
  NativeNavModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNavModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  void emitOnNavigationReady() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onNavigationReady"]).emit();
  }

  template <typename OnLocationChangedType> void emitOnLocationChanged(OnLocationChangedType value) {
    static_assert(bridging::supportsFromJs<OnLocationChangedType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onLocationChanged"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnArrivalType> void emitOnArrival(OnArrivalType value) {
    static_assert(bridging::supportsFromJs<OnArrivalType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onArrival"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  void emitOnRemainingTimeOrDistanceChanged() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onRemainingTimeOrDistanceChanged"]).emit();
  }

  void emitOnRouteChanged() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onRouteChanged"]).emit();
  }

  void emitOnReroutingRequestedByOffRoute() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onReroutingRequestedByOffRoute"]).emit();
  }

  void emitOnStartGuidance() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onStartGuidance"]).emit();
  }

  template <typename OnTurnByTurnType> void emitOnTurnByTurn(OnTurnByTurnType value) {
    static_assert(bridging::supportsFromJs<OnTurnByTurnType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onTurnByTurn"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnRawLocationChangedType> void emitOnRawLocationChanged(OnRawLocationChangedType value) {
    static_assert(bridging::supportsFromJs<OnRawLocationChangedType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onRawLocationChanged"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  void emitOnTrafficUpdated() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onTrafficUpdated"]).emit();
  }

  template <typename LogDebugInfoType> void emitLogDebugInfo(LogDebugInfoType value) {
    static_assert(bridging::supportsFromJs<LogDebugInfoType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["logDebugInfo"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeNavModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNavModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onNavigationReady"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onLocationChanged"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onArrival"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onRemainingTimeOrDistanceChanged"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onRouteChanged"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onReroutingRequestedByOffRoute"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onStartGuidance"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onTurnByTurn"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onRawLocationChanged"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onTrafficUpdated"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["logDebugInfo"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    jsi::Value initializeNavigator(jsi::Runtime &rt, jsi::Object termsAndConditionsDialogOptions, double taskRemovedBehavior) override {
      static_assert(
          bridging::getParameterCount(&T::initializeNavigator) == 3,
          "Expected initializeNavigator(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::initializeNavigator, jsInvoker_, instance_, std::move(termsAndConditionsDialogOptions), std::move(taskRemovedBehavior));
    }
    jsi::Value cleanup(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::cleanup) == 1,
          "Expected cleanup(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cleanup, jsInvoker_, instance_);
    }
    jsi::Value setDestinations(jsi::Runtime &rt, jsi::Array waypoints, std::optional<jsi::Object> routingOptions, std::optional<jsi::Object> displayOptions) override {
      static_assert(
          bridging::getParameterCount(&T::setDestinations) == 4,
          "Expected setDestinations(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setDestinations, jsInvoker_, instance_, std::move(waypoints), std::move(routingOptions), std::move(displayOptions));
    }
    jsi::Value continueToNextDestination(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::continueToNextDestination) == 1,
          "Expected continueToNextDestination(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::continueToNextDestination, jsInvoker_, instance_);
    }
    jsi::Value clearDestinations(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearDestinations) == 1,
          "Expected clearDestinations(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearDestinations, jsInvoker_, instance_);
    }
    jsi::Value startGuidance(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startGuidance) == 1,
          "Expected startGuidance(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::startGuidance, jsInvoker_, instance_);
    }
    jsi::Value stopGuidance(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopGuidance) == 1,
          "Expected stopGuidance(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopGuidance, jsInvoker_, instance_);
    }
    jsi::Value setSpeedAlertOptions(jsi::Runtime &rt, std::optional<jsi::Object> alertOptions) override {
      static_assert(
          bridging::getParameterCount(&T::setSpeedAlertOptions) == 2,
          "Expected setSpeedAlertOptions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setSpeedAlertOptions, jsInvoker_, instance_, std::move(alertOptions));
    }
    void setAbnormalTerminatingReportingEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setAbnormalTerminatingReportingEnabled) == 2,
          "Expected setAbnormalTerminatingReportingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAbnormalTerminatingReportingEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    jsi::Value setAudioGuidanceType(jsi::Runtime &rt, double index) override {
      static_assert(
          bridging::getParameterCount(&T::setAudioGuidanceType) == 2,
          "Expected setAudioGuidanceType(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setAudioGuidanceType, jsInvoker_, instance_, std::move(index));
    }
    void setBackgroundLocationUpdatesEnabled(jsi::Runtime &rt, bool isEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setBackgroundLocationUpdatesEnabled) == 2,
          "Expected setBackgroundLocationUpdatesEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setBackgroundLocationUpdatesEnabled, jsInvoker_, instance_, std::move(isEnabled));
    }
    void setTurnByTurnLoggingEnabled(jsi::Runtime &rt, bool isEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setTurnByTurnLoggingEnabled) == 2,
          "Expected setTurnByTurnLoggingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTurnByTurnLoggingEnabled, jsInvoker_, instance_, std::move(isEnabled));
    }
    jsi::Value areTermsAccepted(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::areTermsAccepted) == 1,
          "Expected areTermsAccepted(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::areTermsAccepted, jsInvoker_, instance_);
    }
    jsi::Value getCurrentRouteSegment(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentRouteSegment) == 1,
          "Expected getCurrentRouteSegment(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCurrentRouteSegment, jsInvoker_, instance_);
    }
    jsi::Value getRouteSegments(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getRouteSegments) == 1,
          "Expected getRouteSegments(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getRouteSegments, jsInvoker_, instance_);
    }
    jsi::Value getCurrentTimeAndDistance(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentTimeAndDistance) == 1,
          "Expected getCurrentTimeAndDistance(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCurrentTimeAndDistance, jsInvoker_, instance_);
    }
    jsi::Value getTraveledPath(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getTraveledPath) == 1,
          "Expected getTraveledPath(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getTraveledPath, jsInvoker_, instance_);
    }
    jsi::Value getNavSDKVersion(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getNavSDKVersion) == 1,
          "Expected getNavSDKVersion(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getNavSDKVersion, jsInvoker_, instance_);
    }
    jsi::Value stopUpdatingLocation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopUpdatingLocation) == 1,
          "Expected stopUpdatingLocation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopUpdatingLocation, jsInvoker_, instance_);
    }
    jsi::Value startUpdatingLocation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startUpdatingLocation) == 1,
          "Expected startUpdatingLocation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::startUpdatingLocation, jsInvoker_, instance_);
    }
    jsi::Value simulateLocation(jsi::Runtime &rt, jsi::Object location) override {
      static_assert(
          bridging::getParameterCount(&T::simulateLocation) == 2,
          "Expected simulateLocation(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::simulateLocation, jsInvoker_, instance_, std::move(location));
    }
    jsi::Value resumeLocationSimulation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::resumeLocationSimulation) == 1,
          "Expected resumeLocationSimulation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::resumeLocationSimulation, jsInvoker_, instance_);
    }
    jsi::Value pauseLocationSimulation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::pauseLocationSimulation) == 1,
          "Expected pauseLocationSimulation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::pauseLocationSimulation, jsInvoker_, instance_);
    }
    jsi::Value simulateLocationsAlongExistingRoute(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::simulateLocationsAlongExistingRoute) == 2,
          "Expected simulateLocationsAlongExistingRoute(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::simulateLocationsAlongExistingRoute, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value stopLocationSimulation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopLocationSimulation) == 1,
          "Expected stopLocationSimulation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopLocationSimulation, jsInvoker_, instance_);
    }
    void resetTermsAccepted(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::resetTermsAccepted) == 1,
          "Expected resetTermsAccepted(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::resetTermsAccepted, jsInvoker_, instance_);
    }

  private:
    friend class NativeNavModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeNavViewModuleCameraPositionSpec

template <typename P0, typename P1, typename P2, typename P3>
struct NativeNavViewModuleCameraPositionSpec {
  P0 target;
  P1 bearing;
  P2 tilt;
  P3 zoom;
  bool operator==(const NativeNavViewModuleCameraPositionSpec &other) const {
    return target == other.target && bearing == other.bearing && tilt == other.tilt && zoom == other.zoom;
  }
};

template <typename T>
struct NativeNavViewModuleCameraPositionSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.target)>(rt, value.getProperty(rt, "target"), jsInvoker),
      bridging::fromJs<decltype(types.bearing)>(rt, value.getProperty(rt, "bearing"), jsInvoker),
      bridging::fromJs<decltype(types.tilt)>(rt, value.getProperty(rt, "tilt"), jsInvoker),
      bridging::fromJs<decltype(types.zoom)>(rt, value.getProperty(rt, "zoom"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::Object> targetToJs(jsi::Runtime &rt, decltype(types.target) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> bearingToJs(jsi::Runtime &rt, decltype(types.bearing) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> tiltToJs(jsi::Runtime &rt, decltype(types.tilt) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zoomToJs(jsi::Runtime &rt, decltype(types.zoom) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.target) {
      result.setProperty(rt, "target", bridging::toJs(rt, value.target.value(), jsInvoker));
    }
    if (value.bearing) {
      result.setProperty(rt, "bearing", bridging::toJs(rt, value.bearing.value(), jsInvoker));
    }
    if (value.tilt) {
      result.setProperty(rt, "tilt", bridging::toJs(rt, value.tilt.value(), jsInvoker));
    }
    if (value.zoom) {
      result.setProperty(rt, "zoom", bridging::toJs(rt, value.zoom.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavViewModuleCircleOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct NativeNavViewModuleCircleOptionsSpec {
  P0 center;
  P1 id;
  P2 radius;
  P3 strokeWidth;
  P4 strokeColor;
  P5 fillColor;
  P6 clickable;
  P7 visible;
  P8 zIndex;
  bool operator==(const NativeNavViewModuleCircleOptionsSpec &other) const {
    return center == other.center && id == other.id && radius == other.radius && strokeWidth == other.strokeWidth && strokeColor == other.strokeColor && fillColor == other.fillColor && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavViewModuleCircleOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.center)>(rt, value.getProperty(rt, "center"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.radius)>(rt, value.getProperty(rt, "radius"), jsInvoker),
      bridging::fromJs<decltype(types.strokeWidth)>(rt, value.getProperty(rt, "strokeWidth"), jsInvoker),
      bridging::fromJs<decltype(types.strokeColor)>(rt, value.getProperty(rt, "strokeColor"), jsInvoker),
      bridging::fromJs<decltype(types.fillColor)>(rt, value.getProperty(rt, "fillColor"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object centerToJs(jsi::Runtime &rt, decltype(types.center) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static double radiusToJs(jsi::Runtime &rt, decltype(types.radius) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> strokeWidthToJs(jsi::Runtime &rt, decltype(types.strokeWidth) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> strokeColorToJs(jsi::Runtime &rt, decltype(types.strokeColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fillColorToJs(jsi::Runtime &rt, decltype(types.fillColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "center", bridging::toJs(rt, value.center, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    result.setProperty(rt, "radius", bridging::toJs(rt, value.radius, jsInvoker));
    if (value.strokeWidth) {
      result.setProperty(rt, "strokeWidth", bridging::toJs(rt, value.strokeWidth.value(), jsInvoker));
    }
    if (value.strokeColor) {
      result.setProperty(rt, "strokeColor", bridging::toJs(rt, value.strokeColor.value(), jsInvoker));
    }
    if (value.fillColor) {
      result.setProperty(rt, "fillColor", bridging::toJs(rt, value.fillColor.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavViewModuleMarkerOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
struct NativeNavViewModuleMarkerOptionsSpec {
  P0 position;
  P1 id;
  P2 imgPath;
  P3 title;
  P4 snippet;
  P5 alpha;
  P6 rotation;
  P7 draggable;
  P8 flat;
  P9 visible;
  P10 zIndex;
  bool operator==(const NativeNavViewModuleMarkerOptionsSpec &other) const {
    return position == other.position && id == other.id && imgPath == other.imgPath && title == other.title && snippet == other.snippet && alpha == other.alpha && rotation == other.rotation && draggable == other.draggable && flat == other.flat && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavViewModuleMarkerOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.position)>(rt, value.getProperty(rt, "position"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.imgPath)>(rt, value.getProperty(rt, "imgPath"), jsInvoker),
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.snippet)>(rt, value.getProperty(rt, "snippet"), jsInvoker),
      bridging::fromJs<decltype(types.alpha)>(rt, value.getProperty(rt, "alpha"), jsInvoker),
      bridging::fromJs<decltype(types.rotation)>(rt, value.getProperty(rt, "rotation"), jsInvoker),
      bridging::fromJs<decltype(types.draggable)>(rt, value.getProperty(rt, "draggable"), jsInvoker),
      bridging::fromJs<decltype(types.flat)>(rt, value.getProperty(rt, "flat"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object positionToJs(jsi::Runtime &rt, decltype(types.position) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> imgPathToJs(jsi::Runtime &rt, decltype(types.imgPath) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> snippetToJs(jsi::Runtime &rt, decltype(types.snippet) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> alphaToJs(jsi::Runtime &rt, decltype(types.alpha) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> rotationToJs(jsi::Runtime &rt, decltype(types.rotation) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> draggableToJs(jsi::Runtime &rt, decltype(types.draggable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> flatToJs(jsi::Runtime &rt, decltype(types.flat) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "position", bridging::toJs(rt, value.position, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    if (value.imgPath) {
      result.setProperty(rt, "imgPath", bridging::toJs(rt, value.imgPath.value(), jsInvoker));
    }
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.snippet) {
      result.setProperty(rt, "snippet", bridging::toJs(rt, value.snippet.value(), jsInvoker));
    }
    if (value.alpha) {
      result.setProperty(rt, "alpha", bridging::toJs(rt, value.alpha.value(), jsInvoker));
    }
    if (value.rotation) {
      result.setProperty(rt, "rotation", bridging::toJs(rt, value.rotation.value(), jsInvoker));
    }
    if (value.draggable) {
      result.setProperty(rt, "draggable", bridging::toJs(rt, value.draggable.value(), jsInvoker));
    }
    if (value.flat) {
      result.setProperty(rt, "flat", bridging::toJs(rt, value.flat.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavViewModulePolygonOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct NativeNavViewModulePolygonOptionsSpec {
  P0 points;
  P1 id;
  P2 holes;
  P3 strokeWidth;
  P4 strokeColor;
  P5 fillColor;
  P6 geodesic;
  P7 clickable;
  P8 visible;
  P9 zIndex;
  bool operator==(const NativeNavViewModulePolygonOptionsSpec &other) const {
    return points == other.points && id == other.id && holes == other.holes && strokeWidth == other.strokeWidth && strokeColor == other.strokeColor && fillColor == other.fillColor && geodesic == other.geodesic && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavViewModulePolygonOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.points)>(rt, value.getProperty(rt, "points"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.holes)>(rt, value.getProperty(rt, "holes"), jsInvoker),
      bridging::fromJs<decltype(types.strokeWidth)>(rt, value.getProperty(rt, "strokeWidth"), jsInvoker),
      bridging::fromJs<decltype(types.strokeColor)>(rt, value.getProperty(rt, "strokeColor"), jsInvoker),
      bridging::fromJs<decltype(types.fillColor)>(rt, value.getProperty(rt, "fillColor"), jsInvoker),
      bridging::fromJs<decltype(types.geodesic)>(rt, value.getProperty(rt, "geodesic"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array pointsToJs(jsi::Runtime &rt, decltype(types.points) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array holesToJs(jsi::Runtime &rt, decltype(types.holes) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> strokeWidthToJs(jsi::Runtime &rt, decltype(types.strokeWidth) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> strokeColorToJs(jsi::Runtime &rt, decltype(types.strokeColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fillColorToJs(jsi::Runtime &rt, decltype(types.fillColor) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> geodesicToJs(jsi::Runtime &rt, decltype(types.geodesic) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "points", bridging::toJs(rt, value.points, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    result.setProperty(rt, "holes", bridging::toJs(rt, value.holes, jsInvoker));
    if (value.strokeWidth) {
      result.setProperty(rt, "strokeWidth", bridging::toJs(rt, value.strokeWidth.value(), jsInvoker));
    }
    if (value.strokeColor) {
      result.setProperty(rt, "strokeColor", bridging::toJs(rt, value.strokeColor.value(), jsInvoker));
    }
    if (value.fillColor) {
      result.setProperty(rt, "fillColor", bridging::toJs(rt, value.fillColor.value(), jsInvoker));
    }
    if (value.geodesic) {
      result.setProperty(rt, "geodesic", bridging::toJs(rt, value.geodesic.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeNavViewModulePolylineOptionsSpec

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativeNavViewModulePolylineOptionsSpec {
  P0 points;
  P1 id;
  P2 color;
  P3 width;
  P4 clickable;
  P5 visible;
  P6 zIndex;
  bool operator==(const NativeNavViewModulePolylineOptionsSpec &other) const {
    return points == other.points && id == other.id && color == other.color && width == other.width && clickable == other.clickable && visible == other.visible && zIndex == other.zIndex;
  }
};

template <typename T>
struct NativeNavViewModulePolylineOptionsSpecBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.points)>(rt, value.getProperty(rt, "points"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.color)>(rt, value.getProperty(rt, "color"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.clickable)>(rt, value.getProperty(rt, "clickable"), jsInvoker),
      bridging::fromJs<decltype(types.visible)>(rt, value.getProperty(rt, "visible"), jsInvoker),
      bridging::fromJs<decltype(types.zIndex)>(rt, value.getProperty(rt, "zIndex"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array pointsToJs(jsi::Runtime &rt, decltype(types.points) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> colorToJs(jsi::Runtime &rt, decltype(types.color) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> clickableToJs(jsi::Runtime &rt, decltype(types.clickable) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> visibleToJs(jsi::Runtime &rt, decltype(types.visible) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> zIndexToJs(jsi::Runtime &rt, decltype(types.zIndex) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "points", bridging::toJs(rt, value.points, jsInvoker));
    if (value.id) {
      result.setProperty(rt, "id", bridging::toJs(rt, value.id.value(), jsInvoker));
    }
    if (value.color) {
      result.setProperty(rt, "color", bridging::toJs(rt, value.color.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.clickable) {
      result.setProperty(rt, "clickable", bridging::toJs(rt, value.clickable.value(), jsInvoker));
    }
    if (value.visible) {
      result.setProperty(rt, "visible", bridging::toJs(rt, value.visible.value(), jsInvoker));
    }
    if (value.zIndex) {
      result.setProperty(rt, "zIndex", bridging::toJs(rt, value.zIndex.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeNavViewModuleCxxSpecJSI : public TurboModule {
protected:
  NativeNavViewModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value addCircle(jsi::Runtime &rt, double viewId, jsi::Object options) = 0;
  virtual jsi::Value addMarker(jsi::Runtime &rt, double viewId, jsi::Object options) = 0;
  virtual jsi::Value addPolyline(jsi::Runtime &rt, double viewId, jsi::Object options) = 0;
  virtual jsi::Value addPolygon(jsi::Runtime &rt, double viewId, jsi::Object options) = 0;
  virtual jsi::Value addGroundOverlay(jsi::Runtime &rt, double viewId, jsi::Object options) = 0;
  virtual jsi::Value moveCamera(jsi::Runtime &rt, double viewId, jsi::Object cameraPosition) = 0;
  virtual jsi::Value getCameraPosition(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value getMyLocation(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value getUiSettings(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value isMyLocationEnabled(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value showRouteOverview(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value clearMapView(jsi::Runtime &rt, double viewId) = 0;
  virtual jsi::Value removeMarker(jsi::Runtime &rt, double viewId, jsi::String id) = 0;
  virtual jsi::Value removePolyline(jsi::Runtime &rt, double viewId, jsi::String id) = 0;
  virtual jsi::Value removePolygon(jsi::Runtime &rt, double viewId, jsi::String id) = 0;
  virtual jsi::Value removeCircle(jsi::Runtime &rt, double viewId, jsi::String id) = 0;
  virtual jsi::Value removeGroundOverlay(jsi::Runtime &rt, double viewId, jsi::String id) = 0;
  virtual jsi::Value setZoomLevel(jsi::Runtime &rt, double viewId, double level) = 0;

};

template <typename T>
class JSI_EXPORT NativeNavViewModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NavViewModule";

protected:
  NativeNavViewModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNavViewModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeNavViewModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNavViewModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value addCircle(jsi::Runtime &rt, double viewId, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addCircle) == 3,
          "Expected addCircle(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addCircle, jsInvoker_, instance_, std::move(viewId), std::move(options));
    }
    jsi::Value addMarker(jsi::Runtime &rt, double viewId, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addMarker) == 3,
          "Expected addMarker(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addMarker, jsInvoker_, instance_, std::move(viewId), std::move(options));
    }
    jsi::Value addPolyline(jsi::Runtime &rt, double viewId, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addPolyline) == 3,
          "Expected addPolyline(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addPolyline, jsInvoker_, instance_, std::move(viewId), std::move(options));
    }
    jsi::Value addPolygon(jsi::Runtime &rt, double viewId, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addPolygon) == 3,
          "Expected addPolygon(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addPolygon, jsInvoker_, instance_, std::move(viewId), std::move(options));
    }
    jsi::Value addGroundOverlay(jsi::Runtime &rt, double viewId, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::addGroundOverlay) == 3,
          "Expected addGroundOverlay(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::addGroundOverlay, jsInvoker_, instance_, std::move(viewId), std::move(options));
    }
    jsi::Value moveCamera(jsi::Runtime &rt, double viewId, jsi::Object cameraPosition) override {
      static_assert(
          bridging::getParameterCount(&T::moveCamera) == 3,
          "Expected moveCamera(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveCamera, jsInvoker_, instance_, std::move(viewId), std::move(cameraPosition));
    }
    jsi::Value getCameraPosition(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::getCameraPosition) == 2,
          "Expected getCameraPosition(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCameraPosition, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value getMyLocation(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::getMyLocation) == 2,
          "Expected getMyLocation(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getMyLocation, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value getUiSettings(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::getUiSettings) == 2,
          "Expected getUiSettings(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getUiSettings, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value isMyLocationEnabled(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::isMyLocationEnabled) == 2,
          "Expected isMyLocationEnabled(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isMyLocationEnabled, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value showRouteOverview(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::showRouteOverview) == 2,
          "Expected showRouteOverview(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::showRouteOverview, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value clearMapView(jsi::Runtime &rt, double viewId) override {
      static_assert(
          bridging::getParameterCount(&T::clearMapView) == 2,
          "Expected clearMapView(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearMapView, jsInvoker_, instance_, std::move(viewId));
    }
    jsi::Value removeMarker(jsi::Runtime &rt, double viewId, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeMarker) == 3,
          "Expected removeMarker(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeMarker, jsInvoker_, instance_, std::move(viewId), std::move(id));
    }
    jsi::Value removePolyline(jsi::Runtime &rt, double viewId, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removePolyline) == 3,
          "Expected removePolyline(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removePolyline, jsInvoker_, instance_, std::move(viewId), std::move(id));
    }
    jsi::Value removePolygon(jsi::Runtime &rt, double viewId, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removePolygon) == 3,
          "Expected removePolygon(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removePolygon, jsInvoker_, instance_, std::move(viewId), std::move(id));
    }
    jsi::Value removeCircle(jsi::Runtime &rt, double viewId, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeCircle) == 3,
          "Expected removeCircle(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeCircle, jsInvoker_, instance_, std::move(viewId), std::move(id));
    }
    jsi::Value removeGroundOverlay(jsi::Runtime &rt, double viewId, jsi::String id) override {
      static_assert(
          bridging::getParameterCount(&T::removeGroundOverlay) == 3,
          "Expected removeGroundOverlay(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeGroundOverlay, jsInvoker_, instance_, std::move(viewId), std::move(id));
    }
    jsi::Value setZoomLevel(jsi::Runtime &rt, double viewId, double level) override {
      static_assert(
          bridging::getParameterCount(&T::setZoomLevel) == 3,
          "Expected setZoomLevel(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setZoomLevel, jsInvoker_, instance_, std::move(viewId), std::move(level));
    }

  private:
    friend class NativeNavViewModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
